{
  "name": "vasync",
  "version": "1.1.1",
  "description": "utilities for observable asynchronous control flow",
  "main": "./lib/vasync.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/davepacheco/node-vasync.git"
  },
  "dependencies": {
    "verror": "1.1.0"
  },
  "engines": [
    "node >=0.6.0"
  ],
  "readme": "# vasync: utilities for observable asynchronous control flow\n\nThis module provides facilities for asynchronous control flow.  There are many\nmodules that do this already (notably async.js).  This one's claim to fame is\naided debuggability: each of the contained functions return a \"status\" object\nwith the following fields:\n\n    operations          array corresponding to the input functions, with\n\n            func            input function\n\n            status          \"pending\", \"ok\", or \"fail\"\n\n            err             returned \"err\" value, if any\n\n            result          returned \"result\" value, if any\n\n    successes\t\t\"result\" field for each of \"operations\" where\n    \t\t\t\"status\" == \"ok\"\n\n    ndone               number of input operations that have completed\n\n    nerrors             number of input operations that have failed\n\nYou can use this from a debugger (or your own monitoring code) to understand\nthe state of an ongoing asynchronous operation.  For example, you could see how\nfar into a pipeline some particular operation is.\n\n\n## parallel(args, callback): invoke N functions in parallel and merge the results\n\nThis function takes a list of input functions (specified by the \"funcs\" property\nof \"args\") and runs them all.  These input functions are expected to be\nasynchronous: they get a \"callback\" argument and should invoke it as\ncallback(err, result).  The error and result will be saved and made available to\nthe original caller when all of these functions complete.\n\nAll errors are combined into a single \"err\" parameter to the final callback (see\nbelow).  You can also observe the progress of the operation as it goes by\nexamining the object returned synchronously by this function.\n\nExample usage:\n\n    status = mod_vasync.parallel({\n        'funcs': [\n             function f1 (callback) { mod_fs.stat('/tmp', callback); },\n             function f2 (callback) { mod_fs.stat('/noexist', callback); },\n             function f3 (callback) { mod_fs.stat('/var', callback); }\n        ]\n    }, function (err, results) {\n            console.log('error: %s', err.message);\n            console.log('results: %s', mod_util.inspect(results, null, 3));\n    });\n\n    console.log('status: %s', mod_sys.inspect(status, null, 3));\n\nIn the first tick, this outputs:\n\n    status: { operations: \n       [ { func: [Function: f1], status: 'pending' },\n         { func: [Function: f2], status: 'pending' },\n         { func: [Function: f3], status: 'pending' } ],\n      successes: [],\n      ndone: 0,\n      nerrors: 0 }\n\nshowing that there are three operations pending and none has yet been started.\nWhen the program finishes, it outputs this error:\n\n    error: first of 1 error: ENOENT, no such file or directory '/noexist'\n\nwhich encapsulates all of the intermediate failures.  This model allows you to\nwrite the final callback like you normally would:\n\n    if (err)\n            return (callback(err));\n\nand still propagate useful information to callers that don't deal with multiple\nerrors (i.e. most callers).\n\nThe example also prints out the detailed final status, including all of the\nerrors and return values:\n\n    results: { operations: \n       [ { func: [Function: f1],\n           status: 'ok',\n           err: null,\n           result: \n            { dev: 140247096,\n              ino: 879368309,\n              mode: 17407,\n              nlink: 9,\n              uid: 0,\n              gid: 3,\n              rdev: 0,\n              size: 754,\n              blksize: 4096,\n              blocks: 8,\n              atime: Thu, 12 Apr 2012 23:18:57 GMT,\n              mtime: Tue, 17 Apr 2012 23:56:34 GMT,\n              ctime: Tue, 17 Apr 2012 23:56:34 GMT } },\n         { func: [Function: f2],\n           status: 'fail',\n           err: { [Error: ENOENT, no such file or directory '/noexist'] errno: 34, code: 'ENOENT', path: '/noexist' },\n           result: undefined },\n         { func: [Function: f3],\n           status: 'ok',\n           err: null,\n           result: \n            { dev: 23658528,\n              ino: 5,\n              mode: 16877,\n              nlink: 27,\n              uid: 0,\n              gid: 0,\n              rdev: -1,\n              size: 27,\n              blksize: 2560,\n              blocks: 3,\n              atime: Fri, 09 Sep 2011 14:28:55 GMT,\n              mtime: Wed, 04 Apr 2012 17:51:20 GMT,\n              ctime: Wed, 04 Apr 2012 17:51:20 GMT } } ],\n      successes: \n       [ { dev: 234881026,\n           ino: 24965,\n           mode: 17407,\n           nlink: 8,\n           uid: 0,\n           gid: 0,\n           rdev: 0,\n           size: 272,\n           blksize: 4096,\n           blocks: 0,\n           atime: Tue, 01 May 2012 16:02:24 GMT,\n           mtime: Tue, 01 May 2012 19:10:35 GMT,\n           ctime: Tue, 01 May 2012 19:10:35 GMT },\n         { dev: 234881026,\n           ino: 216,\n           mode: 16877,\n           nlink: 26,\n           uid: 0,\n           gid: 0,\n           rdev: 0,\n           size: 884,\n           blksize: 4096,\n           blocks: 0,\n           atime: Tue, 01 May 2012 16:02:24 GMT,\n           mtime: Fri, 14 Aug 2009 21:23:03 GMT,\n           ctime: Thu, 28 Oct 2010 21:51:39 GMT } ],\n      ndone: 3,\n      nerrors: 1 }\n\nYou can use this if you want to handle all of the errors individually or to get\nat all of the individual return values.\n\n\n## forEachParallel(args, callback): invoke the same function on N inputs in parallel\n\nThis function is exactly like `parallel`, except that the input is specified as\na *single* function (\"func\") and a list of inputs (\"inputs\").  The function is\ninvoked on each input in parallel.\n\nThis example is exactly equivalent to the one above:\n\n    mod_vasync.forEachParallel({\n        'func': mod_fs.stat,\n        'inputs': [ '/var', '/nonexistent', '/tmp' ]\n    }, function (err, results) {\n        console.log('error: %s', err.message);\n        console.log('results: %s', mod_util.inspect(results, null, 3));\n    });\n\n\n## pipeline(args, callback): invoke N functions in series (and stop on failure)\n\nThe arguments for this function are:\n\n* funcs: input functions, to be invoked in series\n* arg: arbitrary argument that will be passed to each function\n\nThe functions are invoked in order as `func(arg, callback)`, where \"arg\" is the\nuser-supplied argument from \"args\" and \"callback\" should be invoked in the usual\nway.  If any function emits an error, the whole pipeline stops.\n\nThe return value and the arguments to the final callback are exactly the same as\nfor `parallel`.  The error object for the final callback is just the error\nreturned by whatever pipeline function failed (if any).\n\nThis example is similar to the one above, except that it runs the steps in\nsequence and stops early because `pipeline` stops on the first error:\n\n    console.log(mod_vasync.pipeline({\n        'funcs': [\n            function f1 (_, callback) { mod_fs.stat('/tmp', callback); },\n            function f2 (_, callback) { mod_fs.stat('/noexist', callback); },\n            function f3 (_, callback) { mod_fs.stat('/var', callback); }\n        ]\n    }, function (err, results) {\n            console.log('error: %s', err.message);\n            console.log('results: %s', mod_util.inspect(results, null, 3));\n    }));\n\nAs a result, the status after the first tick looks like this:\n\n    { operations: \n       [ { func: [Function: f1], status: 'pending' },\n         { func: [Function: f2], status: 'waiting' },\n         { func: [Function: f3], status: 'waiting' } ],\n      successes: [],\n      ndone: 0,\n      nerrors: 0 }\n\n(Note that the second and third stages are now \"waiting\", rather than \"pending\"\nin the `parallel` case.)  The error reported is:\n\n    error: ENOENT, no such file or directory '/noexist'\n\nand the complete result is:\n\n    results: { operations: \n       [ { func: [Function: f1],\n           status: 'ok',\n           err: null,\n           result: \n            { dev: 140247096,\n              ino: 879368309,\n              mode: 17407,\n              nlink: 9,\n              uid: 0,\n              gid: 3,\n              rdev: 0,\n              size: 754,\n              blksize: 4096,\n              blocks: 8,\n              atime: Thu, 12 Apr 2012 23:18:57 GMT,\n              mtime: Tue, 17 Apr 2012 23:56:34 GMT,\n              ctime: Tue, 17 Apr 2012 23:56:34 GMT } },\n         { func: [Function: f2],\n           status: 'fail',\n           err: { [Error: ENOENT, no such file or directory '/noexist'] errno: 34, code: 'ENOENT', path: '/noexist' },\n           result: undefined },\n         { func: [Function: f3], status: 'waiting' } ],\n      successes: \n       [ { dev: 234881026,\n           ino: 24965,\n           mode: 17407,\n           nlink: 8,\n           uid: 0,\n           gid: 0,\n           rdev: 0,\n           size: 272,\n           blksize: 4096,\n           blocks: 0,\n           atime: Tue, 01 May 2012 16:02:24 GMT,\n           mtime: Tue, 01 May 2012 19:10:35 GMT,\n           ctime: Tue, 01 May 2012 19:10:35 GMT } ],\n      ndone: 2,\n      nerrors: 1 }\n",
  "_id": "vasync@1.1.1",
  "dist": {
    "shasum": "5779d0e9ad67caef840ea084f7def07acf7db88c"
  },
  "_from": "vasync@1.1.1"
}
